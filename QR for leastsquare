# Fast QR Decomp for LSq, store HH instead of computing Q
# 1st output is -1 if A is underdetermined
# 2nd output is R
# 3rd output is H1...Hn in 3-D array such that Hn...H1A = R
def QRdecompF (A):    
    (m,n) = A.shape
    if m < n:
        return -1,0,0;
    
    R = A.copy()
    H = np.zeros((n,m,m))
    for i in range(n):
        I = np.identity(m-i)
        e = I[:,0]
        a = R[i:m,i]
        
        u = a - LA.norm(a)*e
        u = u/LA.norm(u)
        
        uT = np.array([u])
        P = I-2*(uT.T)@uT
        H[i,:,:] = block(np.identity(i),P)
        
        for j in range(i,n):
            R[i:m,j] -= 2*np.dot(u,R[i:m,j])*u
    
    R = np.triu(R)
    return 0, R, H

# LSq method using fastQR above
# S is assumed to be a list of arrays
# (interpreted as column vectors of any size)
def solveLSQR (A,S):
    (m,n) = A.shape
    N = len(S)
    
    for i in range(N):
        j = len(S[i])
        if j!=m:
            return -1,0
        
    [E,R,H] = QRdecompF(A)
    
    if E == -1:
        return -1,0
    
    R = R[0:n,:]
    x = np.zeros((n,N))
    
    for i in range(N):
        c = np.array([S[i]]).T
        
        for j in range(n):
            c = H[j]@c
            
        for j in range(n-1,-1,-1):
            x[j,i] = (c[j] - np.dot(R[j, j+1:n], x[j+1:n,i]))/R[j,j]
            
    return 0, x


#examples:
A = np.array([[1,2,3,4],
              [1,3,2,4],
              [1,5,1,2],
              [1,2,2,1],
              [2,1,1,3]], float)

#each entry of B assumed as column vector!
B = np.array([[1,2,3,4,5],[2,1,5,1,2],[0,1,3,1,1]], object)



X = np.array([[1,2,3],
              [4,5,6],
              [7,8,1],
              [1,1,1]], float)

Y = np.array([[1,2,3,4],[5,6,7,8],[-1,-2,0,3]], object)

[E,x]   = solveLSQR(A,B)
[F,w]   = solveLSQR(X,Y)
print(x)
print(w)
